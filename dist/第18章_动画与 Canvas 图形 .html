<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.48">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <script src="./js/head.js"></script><title>页面的标题 | JavaScript高级程序设计⁴</title><meta name="description" content="页面的描述">
    <link rel="modulepreload" href="/red-treasure-book/dist/assets/app.eb5b74ec.js"><link rel="modulepreload" href="/red-treasure-book/dist/assets/第18章_动画与 Canvas 图形 .html.c560cce9.js"><link rel="modulepreload" href="/red-treasure-book/dist/assets/第18章_动画与 Canvas 图形 .html.9db8d96b.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/index.html.e1b8a732.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第10章_函数.html.753293b1.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第11章_期约与异步函数.html.6b2b2c36.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第12章_BOM.html.b492a4b9.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第13章_客户端检测.html.f77befd0.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第14章_DOM.html.473919e4.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第15章_DOM扩展.html.2df9485a.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第16章 _DOM2和DOM3.html.421a0814.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第17章 _事件.html.48e7b181.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第1章_什么是JavaScript.html.76efd380.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第2章_HTML中的JavaScript.html.11b315c8.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第3章_语言基础.html.3366cb68.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第4章_变量、作用域与内存.html.b33ff378.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第5章_基本引用类型.html.4ebd784c.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第6章_集合引用类型.html.82a92815.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第7章_迭代器与生成器.html.1042f117.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第8章_对象、类与面向对象编程.html.d2fbef43.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第9章_代理与反射.html.5d00cdae.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/404.html.265028f6.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/index.html.48151a6c.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第10章_函数.html.94e5555b.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第11章_期约与异步函数.html.cb3e766e.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第12章_BOM.html.eb6d3f8d.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第13章_客户端检测.html.a7779400.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第14章_DOM.html.63943a29.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第15章_DOM扩展.html.81ffb3f8.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第16章 _DOM2和DOM3.html.42f3cdbd.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第17章 _事件.html.a060d2bc.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第1章_什么是JavaScript.html.957b8ae0.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第2章_HTML中的JavaScript.html.1ce42ce8.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第3章_语言基础.html.d7c412bd.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第4章_变量、作用域与内存.html.80a579cd.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第5章_基本引用类型.html.887ce969.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第6章_集合引用类型.html.3a44af3c.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第7章_迭代器与生成器.html.0da42c07.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第8章_对象、类与面向对象编程.html.9495c14b.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/第9章_代理与反射.html.3aeb0ecc.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/404.html.3d21baef.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/404.f604b4aa.js"><link rel="prefetch" href="/red-treasure-book/dist/assets/Layout.0351f7dc.js">
    <link rel="stylesheet" href="/red-treasure-book/dist/assets/style.92e9c651.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/red-treasure-book/dist/" class=""><!----><span class="site-name">JavaScript高级程序设计⁴</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a class="external-link" href="https://www.cnblogs.com/dshvv" rel="noopener noreferrer" target="_blank" aria-label="博客"><!--[--><!--]--> 博客 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a class="external-link" href="https://www.cnblogs.com/dshvv" rel="noopener noreferrer" target="_blank" aria-label="博客"><!--[--><!--]--> 博客 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a href="/red-treasure-book/dist/" class="sidebar-item sidebar-heading" aria-label="简介"><!--[--><!--]--> 简介 <!--[--><!--]--></a><!----></li><li><a href="/red-treasure-book/dist/%E7%AC%AC1%E7%AB%A0_%E4%BB%80%E4%B9%88%E6%98%AFJavaScript.html" class="sidebar-item sidebar-heading" aria-label="第1章 什么是JavaScript"><!--[--><!--]--> 第1章 什么是JavaScript <!--[--><!--]--></a><!----></li><li><a href="/red-treasure-book/dist/%E7%AC%AC2%E7%AB%A0_HTML%E4%B8%AD%E7%9A%84JavaScript.html" class="sidebar-item sidebar-heading" aria-label="第2章 HTML中的JavaScript"><!--[--><!--]--> 第2章 HTML中的JavaScript <!--[--><!--]--></a><!----></li><li><a href="/red-treasure-book/dist/%E7%AC%AC3%E7%AB%A0_%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.html" class="sidebar-item sidebar-heading" aria-label="第3章 语言基础"><!--[--><!--]--> 第3章 语言基础 <!--[--><!--]--></a><!----></li><li><a href="/red-treasure-book/dist/%E7%AC%AC4%E7%AB%A0_%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98.html" class="sidebar-item sidebar-heading" aria-label="第4章 变量、作用域与内存"><!--[--><!--]--> 第4章 变量、作用域与内存 <!--[--><!--]--></a><!----></li><li><a href="/red-treasure-book/dist/%E7%AC%AC5%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.html" class="sidebar-item sidebar-heading" aria-label="第5章 基本引用类型"><!--[--><!--]--> 第5章 基本引用类型 <!--[--><!--]--></a><!----></li><li><a href="/red-treasure-book/dist/%E7%AC%AC6%E7%AB%A0_%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.html" class="sidebar-item sidebar-heading" aria-label="第6章 集合引用类型"><!--[--><!--]--> 第6章 集合引用类型 <!--[--><!--]--></a><!----></li><li><a href="/red-treasure-book/dist/%E7%AC%AC7%E7%AB%A0_%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8.html" class="sidebar-item sidebar-heading" aria-label="第7章 迭代器与生成器"><!--[--><!--]--> 第7章 迭代器与生成器 <!--[--><!--]--></a><!----></li><li><a href="/red-treasure-book/dist/%E7%AC%AC8%E7%AB%A0_%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.html" class="sidebar-item sidebar-heading" aria-label="第8章 对象、类与面向对象编程"><!--[--><!--]--> 第8章 对象、类与面向对象编程 <!--[--><!--]--></a><!----></li><li><a href="/red-treasure-book/dist/%E7%AC%AC9%E7%AB%A0_%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84.html" class="sidebar-item sidebar-heading" aria-label="第9章 代理与反射"><!--[--><!--]--> 第9章 代理与反射 <!--[--><!--]--></a><!----></li><li><a href="/red-treasure-book/dist/%E7%AC%AC10%E7%AB%A0_%E5%87%BD%E6%95%B0.html" class="sidebar-item sidebar-heading" aria-label="第10章 函数"><!--[--><!--]--> 第10章 函数 <!--[--><!--]--></a><!----></li><li><a href="/red-treasure-book/dist/%E7%AC%AC11%E7%AB%A0_%E6%9C%9F%E7%BA%A6%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0.html" class="sidebar-item sidebar-heading" aria-label="第11章 期约与异步函数"><!--[--><!--]--> 第11章 期约与异步函数 <!--[--><!--]--></a><!----></li><li><a href="/red-treasure-book/dist/%E7%AC%AC12%E7%AB%A0_BOM.html" class="sidebar-item sidebar-heading" aria-label="第12章 BOM"><!--[--><!--]--> 第12章 BOM <!--[--><!--]--></a><!----></li><li><a href="/red-treasure-book/dist/%E7%AC%AC13%E7%AB%A0_%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B.html" class="sidebar-item sidebar-heading" aria-label="第13章 客户端检测"><!--[--><!--]--> 第13章 客户端检测 <!--[--><!--]--></a><!----></li><li><a href="/red-treasure-book/dist/%E7%AC%AC14%E7%AB%A0_DOM.html" class="sidebar-item sidebar-heading" aria-label="第14章 DOM"><!--[--><!--]--> 第14章 DOM <!--[--><!--]--></a><!----></li><li><a href="/red-treasure-book/dist/%E7%AC%AC15%E7%AB%A0_DOM%E6%89%A9%E5%B1%95.html" class="sidebar-item sidebar-heading" aria-label="第15章 DOM 扩展"><!--[--><!--]--> 第15章 DOM 扩展 <!--[--><!--]--></a><!----></li><li><a href="/red-treasure-book/dist/%E7%AC%AC16%E7%AB%A0%20_DOM2%E5%92%8CDOM3.html" class="sidebar-item sidebar-heading" aria-label="第16章 DOM2和DOM3"><!--[--><!--]--> 第16章 DOM2和DOM3 <!--[--><!--]--></a><!----></li><li><a href="/red-treasure-book/dist/%E7%AC%AC17%E7%AB%A0%20_%E4%BA%8B%E4%BB%B6.html" class="sidebar-item sidebar-heading" aria-label="第17章 事件"><!--[--><!--]--> 第17章 事件 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/red-treasure-book/dist/%E7%AC%AC18%E7%AB%A0_%E5%8A%A8%E7%94%BB%E4%B8%8E%20Canvas%20%E5%9B%BE%E5%BD%A2%20.html" class="router-link-active router-link-exact-active router-link-active sidebar-item sidebar-heading active" aria-label="页面的标题"><!--[--><!--]--> 页面的标题 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/red-treasure-book/dist/%E7%AC%AC18%E7%AB%A0_%E5%8A%A8%E7%94%BB%E4%B8%8E%20Canvas%20%E5%9B%BE%E5%BD%A2%20.html#_18-1-使用-requestanimationframe" class="router-link-active router-link-exact-active sidebar-item" aria-label="18.1 使用 requestAnimationFrame"><!--[--><!--]--> 18.1 使用 requestAnimationFrame <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/red-treasure-book/dist/%E7%AC%AC18%E7%AB%A0_%E5%8A%A8%E7%94%BB%E4%B8%8E%20Canvas%20%E5%9B%BE%E5%BD%A2%20.html#_18-1-1-早期定时动画" class="router-link-active router-link-exact-active sidebar-item" aria-label="18.1.1 早期定时动画"><!--[--><!--]--> 18.1.1 早期定时动画 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/red-treasure-book/dist/%E7%AC%AC18%E7%AB%A0_%E5%8A%A8%E7%94%BB%E4%B8%8E%20Canvas%20%E5%9B%BE%E5%BD%A2%20.html#_18-1-2-时间间隔的问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="18.1.2 时间间隔的问题"><!--[--><!--]--> 18.1.2 时间间隔的问题 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/red-treasure-book/dist/%E7%AC%AC18%E7%AB%A0_%E5%8A%A8%E7%94%BB%E4%B8%8E%20Canvas%20%E5%9B%BE%E5%BD%A2%20.html#_18-1-3-requestanimationframe" class="router-link-active router-link-exact-active sidebar-item" aria-label="18.1.3 requestAnimationFrame"><!--[--><!--]--> 18.1.3 requestAnimationFrame <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/red-treasure-book/dist/%E7%AC%AC18%E7%AB%A0_%E5%8A%A8%E7%94%BB%E4%B8%8E%20Canvas%20%E5%9B%BE%E5%BD%A2%20.html#_18-1-4-cancelanimationframe" class="router-link-active router-link-exact-active sidebar-item" aria-label="18.1.4 cancelAnimationFrame"><!--[--><!--]--> 18.1.4 cancelAnimationFrame <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/red-treasure-book/dist/%E7%AC%AC18%E7%AB%A0_%E5%8A%A8%E7%94%BB%E4%B8%8E%20Canvas%20%E5%9B%BE%E5%BD%A2%20.html#_18-1-5-通过-requestanimationframe-节流" class="router-link-active router-link-exact-active sidebar-item" aria-label="18.1.5 通过 requestAnimationFrame 节流"><!--[--><!--]--> 18.1.5 通过 requestAnimationFrame 节流 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/red-treasure-book/dist/%E7%AC%AC18%E7%AB%A0_%E5%8A%A8%E7%94%BB%E4%B8%8E%20Canvas%20%E5%9B%BE%E5%BD%A2%20.html#_18-2-基本的画布功能" class="router-link-active router-link-exact-active sidebar-item" aria-label="18.2 基本的画布功能"><!--[--><!--]--> 18.2 基本的画布功能 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/red-treasure-book/dist/%E7%AC%AC18%E7%AB%A0_%E5%8A%A8%E7%94%BB%E4%B8%8E%20Canvas%20%E5%9B%BE%E5%BD%A2%20.html#_18-3-2d-绘图上下文" class="router-link-active router-link-exact-active sidebar-item" aria-label="18.3 2D 绘图上下文"><!--[--><!--]--> 18.3 2D 绘图上下文 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/red-treasure-book/dist/%E7%AC%AC18%E7%AB%A0_%E5%8A%A8%E7%94%BB%E4%B8%8E%20Canvas%20%E5%9B%BE%E5%BD%A2%20.html#_18-3-1-填充和描边" class="router-link-active router-link-exact-active sidebar-item" aria-label="18.3.1 填充和描边"><!--[--><!--]--> 18.3.1 填充和描边 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/red-treasure-book/dist/%E7%AC%AC18%E7%AB%A0_%E5%8A%A8%E7%94%BB%E4%B8%8E%20Canvas%20%E5%9B%BE%E5%BD%A2%20.html#_18-3-2-绘制矩形" class="router-link-active router-link-exact-active sidebar-item" aria-label="18.3.2 绘制矩形"><!--[--><!--]--> 18.3.2 绘制矩形 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/red-treasure-book/dist/%E7%AC%AC18%E7%AB%A0_%E5%8A%A8%E7%94%BB%E4%B8%8E%20Canvas%20%E5%9B%BE%E5%BD%A2%20.html#_18-3-3-绘制路径" class="router-link-active router-link-exact-active sidebar-item" aria-label="18.3.3 绘制路径"><!--[--><!--]--> 18.3.3 绘制路径 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/red-treasure-book/dist/%E7%AC%AC18%E7%AB%A0_%E5%8A%A8%E7%94%BB%E4%B8%8E%20Canvas%20%E5%9B%BE%E5%BD%A2%20.html#_18-3-4-绘制文本" class="router-link-active router-link-exact-active sidebar-item" aria-label="18.3.4 绘制文本"><!--[--><!--]--> 18.3.4 绘制文本 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/red-treasure-book/dist/%E7%AC%AC18%E7%AB%A0_%E5%8A%A8%E7%94%BB%E4%B8%8E%20Canvas%20%E5%9B%BE%E5%BD%A2%20.html#_18-3-5-变换" class="router-link-active router-link-exact-active sidebar-item" aria-label="18.3.5 变换"><!--[--><!--]--> 18.3.5 变换 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="第-18-章-动画与-canvas-图形" tabindex="-1"><a class="header-anchor" href="#第-18-章-动画与-canvas-图形" aria-hidden="true">#</a> 第 18 章 动画与 Canvas 图形</h1><p>本章内容： 使用 requestAnimationFrame、理解<code>&lt;canvas&gt;</code>元素、绘制简单 2D 图形、使用 WebGL 绘制 3D 图形</p><p>图形和动画已经日益成为浏览器中现代 Web 应用程序的必备功能，但实现起来仍然比较困难。视觉上复杂的功能要求性能调优和硬件加速，不能拖慢浏览器。目前已经有一套日趋完善的 API 和工具可以用来开发此类功能。</p><p>毋庸置疑，<code>&lt;canvas&gt;</code>是 HTML5 最受欢迎的新特性。这个元素会占据一块页面区域，让 JavaScript 可以动态在上面绘制图片。<code>&lt;canvas&gt;</code>最早是苹果公司提出并准备用在控制面板中的，随着其他浏览器的迅速跟进，HTML5 将其纳入标准。目前所有主流浏览器都在某种程度上支持<code>&lt;canvas&gt;</code>元素。</p><p>与浏览器环境中的其他部分一样，<code>&lt;canvas&gt;</code>自身提供了一些 API，但并非所有浏览器都支持这些 API，其中包括支持基础绘图能力的 2D 上下文和被称为 WebGL 的 3D 上下文。支持的浏览器的最新版本现在都支持 2D 上下文和 WebGL。</p><h2 id="_18-1-使用-requestanimationframe" tabindex="-1"><a class="header-anchor" href="#_18-1-使用-requestanimationframe" aria-hidden="true">#</a> 18.1 使用 requestAnimationFrame</h2><p>很长时间以来，计时器和定时执行都是 JavaScript 动画最先进的工具。虽然 CSS 过渡和动画方便了 Web 开发者实现某些动画，但 JavaScript 动画领域多年来进展甚微。Firefox 4 率先在浏览器中为 JavaScript 动画增加了一个名为 mozRequestAnimationFrame()方法的 API。这个方法会告诉浏览器要执行动画了，于是浏览器可以通过最优方式确定重绘的时序。自从出现之后，这个 API 被广泛采用，现在作为 requestAnimationFrame()方法已经得到各大浏览器的支持。</p><h3 id="_18-1-1-早期定时动画" tabindex="-1"><a class="header-anchor" href="#_18-1-1-早期定时动画" aria-hidden="true">#</a> 18.1.1 早期定时动画</h3><p>以前，在 JavaScript 中创建动画基本上就是使用 setInterval()来控制动画的执行。下面的例子展示了使用 setInterval()的基本模式：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">updateAnimations</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">doAnimation1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">doAnimation2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 其他任务</span>
  <span class="token punctuation">}</span>
  <span class="token function">setInterval</span><span class="token punctuation">(</span>updateAnimations<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>作为一个小型动画库的标配，这个 updateAnimations()方法会周期性运行注册的动画任务，并反映出每个任务的变化（例如，同时更新滚动新闻和进度条）。如果没有动画需要更新，则这个方法既可以什么也不做，直接退出，也可以停止动画循环，等待其他需要更新的动画。</p><p>这种定时动画的问题在于无法准确知晓循环之间的延时。定时间隔必须足够短，这样才能让不同的动画类型都能平滑顺畅，但又要足够长，以便产生浏览器可以渲染出来的变化。一般计算机显示器的屏幕刷新率都是 60Hz，基本上意味着每秒需要重绘 60 次。大多数浏览器会限制重绘频率，使其不超出屏幕的刷新率，这是因为超过刷新率，用户也感知不到。</p><p>因此，实现平滑动画最佳的重绘间隔为 1000 毫秒/60，大约 17 毫秒。以这个速度重绘可以实现最平滑的动画，因为这已经是浏览器的极限了。如果同时运行多个动画，可能需要加以限流，以免 17 毫秒的重绘间隔过快，导致动画过早运行完。</p><p>虽然使用 setInterval()的定时动画比使用多个 setTimeout()实现循环效率更高，但也不是没有问题。无论 setInterval()还是 setTimeout()都是不能保证时间精度的。作为第二个参数的延时只能保证何时会把代码添加到浏览器的任务队列，不能保证添加到队列就会立即运行。如果队列前面还有其他任务，那么就要等这些任务执行完再执行。简单来讲，这里毫秒延时并不是说何时这些代码会执行，而只是说到时候会把回调加到任务队列。如果添加到队列后，主线程还被其他任务占用，比如正在处理用户操作，那么回调就不会马上执行。</p><h3 id="_18-1-2-时间间隔的问题" tabindex="-1"><a class="header-anchor" href="#_18-1-2-时间间隔的问题" aria-hidden="true">#</a> 18.1.2 时间间隔的问题</h3><p>知道何时绘制下一帧是创造平滑动画的关键。直到几年前，都没有办法确切保证何时能让浏览器把下一帧绘制出来。随着<code>&lt;canvas&gt;</code>的流行和 HTML5 游戏的兴起，开发者发现 setInterval()和 setTimeout()的不精确是个大问题。</p><p>浏览器自身计时器的精度让这个问题雪上加霜。浏览器的计时器精度不足毫秒。以下是几个浏览器计时器的精度情况：</p><ul><li>IE8 及更早版本的计时器精度为 15.625 毫秒；</li><li>IE9 及更晚版本的计时器精度为 4 毫秒；</li><li>Firefox 和 Safari 的计时器精度为约 10 毫秒；</li><li>Chrome 的计时器精度为 4 毫秒。</li></ul><p>IE9 之前版本的计时器精度是 15.625 毫秒，意味着 0 ～ 15 范围内的任何值最终要么是 0，要么是 15，不可能是别的数。IE9 把计时器精度改进为 4 毫秒，但这对于动画而言还是不够精确。Chrome 计时器精度是 4 毫秒，而 Firefox 和 Safari 是 10 毫秒。更麻烦的是，浏览器又开始对切换到后台或不活跃标签页中的计时器执行限流。因此即使将时间间隔设定为最优，也免不了只能得到近似的结果。</p><h3 id="_18-1-3-requestanimationframe" tabindex="-1"><a class="header-anchor" href="#_18-1-3-requestanimationframe" aria-hidden="true">#</a> 18.1.3 requestAnimationFrame</h3><p>Mozilla 的 Robert O’Callahan 一直在思考这个问题，并提出了一个独特的方案。他指出，浏览器知道 CSS 过渡和动画应该什么时候开始，并据此计算出正确的时间间隔，到时间就去刷新用户界面。但对于 JavaScript 动画，浏览器不知道动画什么时候开始。他给出的方案是创造一个名为 mozRequestAnimationFrame()的新方法，用以通知浏览器某些 JavaScript 代码要执行动画了。这样浏览器就可以在运行某些代码后进行适当的优化。目前所有浏览器都支持这个方法不带前缀的版本，即 requestAnimationFrame()。</p><p>requestAnimationFrame()方法接收一个参数，此参数是一个要在重绘屏幕前调用的函数。这个函数就是修改 DOM 样式以反映下一次重绘有什么变化的地方。为了实现动画循环，可以把多个 requestAnimationFrame()调用串联起来，就像以前使用 setTimeout()时一样：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">updateProgress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;status&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>width <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>width<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token string">&quot;%&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token string">&quot;100%&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span>updateProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span>updateProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为 requestAnimationFrame()只会调用一次传入的函数，所以每次更新用户界面时需要再手动调用它一次。同样，也需要控制动画何时停止。结果就会得到非常平滑的动画。</p><p>目前为止，requestAnimationFrame()已经解决了浏览器不知道 JavaScript 动画何时开始的问题，以及最佳间隔是多少的问题，但是，不知道自己的代码何时实际执行的问题呢？这个方案同样也给出了解决方法。</p><p>传给 requestAnimationFrame()的函数实际上可以接收一个参数，此参数是一个 DOMHighResTimeStamp 的实例（比如 performance.now()返回的值），表示下次重绘的时间。这一点非常重要：requestAnimationFrame()实际上把重绘任务安排在了未来一个已知的时间点上，而且通过这个参数告诉了开发者。基于这个参数，就可以更好地决定如何调优动画了。</p><h3 id="_18-1-4-cancelanimationframe" tabindex="-1"><a class="header-anchor" href="#_18-1-4-cancelanimationframe" aria-hidden="true">#</a> 18.1.4 cancelAnimationFrame</h3><p>与 setTimeout()类似，requestAnimationFrame()也返回一个请求 ID，可以用于通过另一个方法 cancelAnimationFrame()来取消重绘任务。下面的例子展示了刚把一个任务加入队列又立即将其取消：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> requestID <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Repaint!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
window<span class="token punctuation">.</span><span class="token function">cancelAnimationFrame</span><span class="token punctuation">(</span>requestID<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_18-1-5-通过-requestanimationframe-节流" tabindex="-1"><a class="header-anchor" href="#_18-1-5-通过-requestanimationframe-节流" aria-hidden="true">#</a> 18.1.5 通过 requestAnimationFrame 节流</h3><p>requestAnimationFrame 这个名字有时候会让人误解，因为看不出来它跟排期任务有关。支持这个方法的浏览器实际上会暴露出作为钩子的回调队列。所谓钩子（hook），就是浏览器在执行下一次重绘之前的一个点。这个回调队列是一个可修改的函数列表，包含应该在重绘之前调用的函数。每次调用 requestAnimationFrame()都会在队列上推入一个回调函数，队列的长度没有限制。</p><p>这个回调队列的行为不一定跟动画有关。不过，通过 requestAnimationFrame()递归地向队列中加入回调函数，可以保证每次重绘最多只调用一次回调函数。这是一个非常好的节流工具。在频繁执行影响页面外观的代码时（比如滚动事件监听器），可以利用这个回调队列进行节流。</p><p>先来看一个原生实现，其中的滚动事件监听器每次触发都会调用名为 expensiveOperation()（耗时操作）的函数。当向下滚动网页时，这个事件很快就会被触发并执行成百上千次：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">expensiveOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Invoked at&quot;</span><span class="token punctuation">,</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;scroll&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">expensiveOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果想把事件处理程序的调用限制在每次重绘前发生，那么可以像这样下面把它封装到 requestAnimationFrame()调用中：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">expensiveOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Invoked at&quot;</span><span class="token punctuation">,</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;scroll&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  window<span class="token punctuation">.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span>expensiveOperation<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样会把所有回调的执行集中在重绘钩子，但不会过滤掉每次重绘的多余调用。此时，定义一个标志变量，由回调设置其开关状态，就可以将多余的调用屏蔽：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> enqueued <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">expensiveOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Invoked at&quot;</span><span class="token punctuation">,</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  enqueued <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;scroll&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>enqueued<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    enqueued <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    window<span class="token punctuation">.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span>expensiveOperation<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为重绘是非常频繁的操作，所以这还算不上真正的节流。更好的办法是配合使用一个计时器来限制操作执行的频率。这样，计时器可以限制实际的操作执行间隔，而 requestAnimationFrame 控制在浏览器的哪个渲染周期中执行。下面的例子可以将回调限制为不超过 50 毫秒执行一次：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> enabled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">expensiveOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Invoked at&quot;</span><span class="token punctuation">,</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;scroll&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>enabled<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    enabled <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    window<span class="token punctuation">.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span>expensiveOperation<span class="token punctuation">)</span><span class="token punctuation">;</span>
    window<span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>enabled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_18-2-基本的画布功能" tabindex="-1"><a class="header-anchor" href="#_18-2-基本的画布功能" aria-hidden="true">#</a> 18.2 基本的画布功能</h2><p>创建<code>&lt;canvas&gt;</code>元素时至少要设置其 width 和 height 属性，这样才能告诉浏览器在多大面积上绘图。出现在开始和结束标签之间的内容是后备数据，会在浏览器不支持<code>&lt;canvas&gt;</code>元素时显示。比如：</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>canvas</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>drawing<span class="token punctuation">&quot;</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>200<span class="token punctuation">&quot;</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>200<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>A drawing of something.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>canvas</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>与其他元素一样，width 和 height 属性也可以在 DOM 节点上设置，因此可以随时修改。整个元素还可以通过 CSS 添加样式，并且元素在添加样式或实际绘制内容前是不可见的。</p><p>要在画布上绘制图形，首先要取得绘图上下文。使用 getContext()方法可以获取对绘图上下文的引用。对于平面图形，需要给这个方法传入参数&quot;2d&quot;，表示要获取 2D 上下文对象：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> drawing <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;drawing&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 确保浏览器支持&lt;canvas&gt;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>drawing<span class="token punctuation">.</span>getContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> context <span class="token operator">=</span> drawing<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">&quot;2d&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 其他代码</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用<code>&lt;canvas&gt;</code>元素时，最好先测试一下 getContext()方法是否存在。有些浏览器对 HTML 规范中没有的元素会创建默认 HTML 元素对象。这就意味着即使 drawing 包含一个有效的元素引用，getContext()方法也未必存在。</p><p>可以使用 toDataURL()方法导出<code>&lt;canvas&gt;</code>元素上的图像。这个方法接收一个参数：要生成图像的 MIME 类型（与用来创建图形的上下文无关）。例如，要从画布上导出一张 PNG 格式的图片，可以这样做：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> drawing <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;drawing&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 确保浏览器支持&lt;canvas&gt;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>drawing<span class="token punctuation">.</span>getContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 取得图像的数据 URI</span>
  <span class="token keyword">let</span> imgURI <span class="token operator">=</span> drawing<span class="token punctuation">.</span><span class="token function">toDataURL</span><span class="token punctuation">(</span><span class="token string">&quot;image/png&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 显示图片</span>
  <span class="token keyword">let</span> image <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;img&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  image<span class="token punctuation">.</span>src <span class="token operator">=</span> imgURI<span class="token punctuation">;</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>image<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>浏览器默认将图像编码为 PNG 格式，除非另行指定。Firefox 和 Opera 还支持传入&quot;image/jpeg&quot;进行 JPEG 编码。因为这个方法是后来才增加到规范中的，所以支持的浏览器也是在后面的版本实现的，包括 IE9、Firefox 3.5 和 Opera 10。</p><div class="custom-container tip"><p class="custom-container-title">注意</p><p>如果画布中的图像是其他域绘制过来的，toDataURL()方法就会抛出错误。相关内容本章后面会讨论。</p></div><h2 id="_18-3-2d-绘图上下文" tabindex="-1"><a class="header-anchor" href="#_18-3-2d-绘图上下文" aria-hidden="true">#</a> 18.3 2D 绘图上下文</h2><p>2D 绘图上下文提供了绘制 2D 图形的方法，包括矩形、弧形和路径。2D 上下文的坐标原点(0, 0)在<code>&lt;canvas&gt;</code>元素的左上角。所有坐标值都相对于该点计算，因此 x 坐标向右增长，y 坐标向下增长。默认情况下，width 和 height 表示两个方向上像素的最大值。</p><h3 id="_18-3-1-填充和描边" tabindex="-1"><a class="header-anchor" href="#_18-3-1-填充和描边" aria-hidden="true">#</a> 18.3.1 填充和描边</h3><p>2D 上下文有两个基本绘制操作：填充和描边。填充以指定样式（颜色、渐变或图像）自动填充形状，而描边只为图形边界着色。大多数 2D 上下文操作有填充和描边的变体，显示效果取决于两个属性：fillStyle 和 strokeStyle。</p><p>这两个属性可以是字符串、渐变对象或图案对象，默认值都为&quot;#000000&quot;。字符串表示颜色值，可以是 CSS 支持的任意格式：名称、十六进制代码、rgb、rgba、hsl 或 hsla。比如：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> drawing <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;drawing&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 确保浏览器支持&lt;canvas&gt;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>drawing<span class="token punctuation">.</span>getContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> context <span class="token operator">=</span> drawing<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">&quot;2d&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  context<span class="token punctuation">.</span>strokeStyle <span class="token operator">=</span> <span class="token string">&quot;red&quot;</span><span class="token punctuation">;</span>
  context<span class="token punctuation">.</span>fillStyle <span class="token operator">=</span> <span class="token string">&quot;#0000ff&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里把 strokeStyle 设置为&quot;red&quot;（CSS 颜色名称），把 fillStyle 设置为&quot;#0000ff&quot;（蓝色）。所有与描边和填充相关的操作都会使用这两种样式，除非再次修改。这两个属性也可以是渐变或图案，本章后面会讨论。</p><h3 id="_18-3-2-绘制矩形" tabindex="-1"><a class="header-anchor" href="#_18-3-2-绘制矩形" aria-hidden="true">#</a> 18.3.2 绘制矩形</h3><p>矩形是唯一一个可以直接在 2D 绘图上下文中绘制的形状。与绘制矩形相关的方法有 3 个：fillRect()、strokeRect()和 clearRect()。这些方法都接收 4 个参数：矩形 x 坐标、矩形 y 坐标、矩形宽度和矩形高度。这几个参数的单位都是像素。</p><p>fillRect()方法用于以指定颜色在画布上绘制并填充矩形。填充的颜色使用 fillStyle 属性指定。来看下面的例子：</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>canvas</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>drawing<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>canvas</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">let</span> drawing <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;drawing&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>drawing<span class="token punctuation">.</span>getContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> context <span class="token operator">=</span> drawing<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">&quot;2d&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    context<span class="token punctuation">.</span>fillStyle <span class="token operator">=</span> <span class="token string">&quot;#ff0000&quot;</span><span class="token punctuation">;</span>
    context<span class="token punctuation">.</span><span class="token function">fillRect</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    context<span class="token punctuation">.</span>fillStyle <span class="token operator">=</span> <span class="token string">&quot;rgba(0,0,255,0.5)&quot;</span><span class="token punctuation">;</span>
    context<span class="token punctuation">.</span><span class="token function">fillRect</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上代码先将 fillStyle 设置为红色并在坐标点(10, 10)绘制了一个宽高均为 50 像素的矩形。接着，使用 rgba()格式将 fillStyle 设置为半透明蓝色，并绘制了另一个与第一个部分重叠的矩形。结果就是可以透过蓝色矩形看到红色矩形（见图 18-1）。</p><iframe src="/red-treasure-book/dist/html/18-1.html" frameborder="0" scrolling="no"></iframe><p>strokeRect()方法使用通过 strokeStyle 属性指定的颜色绘制矩形轮廓。下面是一个例子：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> drawing <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;drawing&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 确保浏览器支持&lt;canvas&gt;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>drawing<span class="token punctuation">.</span>getContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> context <span class="token operator">=</span> drawing<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">&quot;2d&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/*
   * 引自 MDN 文档
   */</span>
  <span class="token comment">// 绘制红色轮廓的矩形</span>
  context<span class="token punctuation">.</span>strokeStyle <span class="token operator">=</span> <span class="token string">&quot;#ff0000&quot;</span><span class="token punctuation">;</span>
  context<span class="token punctuation">.</span><span class="token function">strokeRect</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 绘制半透明蓝色轮廓的矩形</span>
  context<span class="token punctuation">.</span>strokeStyle <span class="token operator">=</span> <span class="token string">&quot;rgba(0,0,255,0.5)&quot;</span><span class="token punctuation">;</span>
  context<span class="token punctuation">.</span><span class="token function">strokeRect</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上代码同样绘制了两个重叠的矩形，不过只有轮廓，而不是实心的（见图 18-2）。</p><iframe src="/red-treasure-book/dist/html/18-2.html" frameborder="0" scrolling="no"></iframe><div class="custom-container tip"><p class="custom-container-title">注意</p><p>描边宽度由 lineWidth 属性控制，它可以是任意整数值。类似地，lineCap 属性控制线条端点的形状［&quot;butt&quot;（平头）、&quot;round&quot;（出圆头）或&quot;square&quot;（出方头）］，而 lineJoin 属性控制线条交点的形状［&quot;round&quot;（圆转）、&quot;bevel&quot;（取平）或&quot;miter&quot;（出尖）］。</p></div><p>使用 clearRect()方法可以擦除画布中某个区域。该方法用于把绘图上下文中的某个区域变透明。通过先绘制形状再擦除指定区域，可以创建出有趣的效果，比如从已有矩形中开个孔。来看下面的例子：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> drawing <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;drawing&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 确保浏览器支持&lt;canvas&gt;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>drawing<span class="token punctuation">.</span>getContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> context <span class="token operator">=</span> drawing<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">&quot;2d&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/*
   * 引自 MDN 文档
   */</span>
  <span class="token comment">// 绘制红色矩形</span>
  context<span class="token punctuation">.</span>fillStyle <span class="token operator">=</span> <span class="token string">&quot;#ff0000&quot;</span><span class="token punctuation">;</span>
  context<span class="token punctuation">.</span><span class="token function">fillRect</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 绘制半透明蓝色矩形</span>
  context<span class="token punctuation">.</span>fillStyle <span class="token operator">=</span> <span class="token string">&quot;rgba(0,0,255,0.5)&quot;</span><span class="token punctuation">;</span>
  context<span class="token punctuation">.</span><span class="token function">fillRect</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 在前两个矩形重叠的区域擦除一个矩形区域</span>
  context<span class="token punctuation">.</span><span class="token function">clearRect</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上代码在两个矩形重叠的区域上擦除了一个小矩形，图 18-3 展示了结果。</p><iframe src="/red-treasure-book/dist/html/18-3.html" frameborder="0" scrolling="no"></iframe><h3 id="_18-3-3-绘制路径" tabindex="-1"><a class="header-anchor" href="#_18-3-3-绘制路径" aria-hidden="true">#</a> 18.3.3 绘制路径</h3><p>2D 绘图上下文支持很多在画布上绘制路径的方法。通过路径可以创建复杂的形状和线条。要绘制路径，必须首先调用 beginPath()方法以表示要开始绘制新路径。然后，再调用下列方法来绘制路径。</p><ul><li>arc(x, y, radius, startAngle, endAngle, counterclockwise)：以坐标(x, y)为圆心，以 radius 为半径绘制一条弧线，起始角度为 startAngle，结束角度为 endAngle（都是弧度）。最后一个参数 counterclockwise 表示是否逆时针计算起始角度和结束角度（默认为顺时针）。</li><li>arcTo(x1, y1, x2, y2, radius)：以给定半径 radius，经由(x1, y1)绘制一条从上一点到(x2, y2)的弧线。</li><li>bezierCurveTo(c1x, c1y, c2x, c2y, x, y)：以(c1x, c1y)和(c2x, c2y)为控制点，绘制一条从上一点到(x, y)的弧线（三次贝塞尔曲线）。</li><li>lineTo(x, y)：绘制一条从上一点到(x, y)的直线。</li><li>moveTo(x, y)：不绘制线条，只把绘制光标移动到(x, y)。</li><li>quadraticCurveTo(cx, cy, x, y)：以(cx, cy)为控制点，绘制一条从上一点到(x, y)的弧线（二次贝塞尔曲线）。</li><li>rect(x, y, width, height)：以给定宽度和高度在坐标点(x, y)绘制一个矩形。这个方法与 strokeRect()和 fillRect()的区别在于，它创建的是一条路径，而不是独立的图形。</li></ul><p>创建路径之后，可以使用 closePath()方法绘制一条返回起点的线。如果路径已经完成，则既可以指定 fillStyle 属性并调用 fill()方法来填充路径，也可以指定 strokeStyle 属性并调用 stroke()方法来描画路径，还可以调用 clip()方法基于已有路径创建一个新剪切区域。</p><p>下面这个例子使用前面提到的方法绘制了一个不带数字的表盘：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> drawing <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;drawing&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 确保浏览器支持&lt;canvas&gt;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>drawing<span class="token punctuation">.</span>getContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> context <span class="token operator">=</span> drawing<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">&quot;2d&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 创建路径</span>
  context<span class="token punctuation">.</span><span class="token function">beginPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 绘制外圆</span>
  context<span class="token punctuation">.</span><span class="token function">arc</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 绘制内圆</span>
  context<span class="token punctuation">.</span><span class="token function">moveTo</span><span class="token punctuation">(</span><span class="token number">194</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  context<span class="token punctuation">.</span><span class="token function">arc</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">94</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 绘制分针</span>
  context<span class="token punctuation">.</span><span class="token function">moveTo</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  context<span class="token punctuation">.</span><span class="token function">lineTo</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 绘制时针</span>
  context<span class="token punctuation">.</span><span class="token function">moveTo</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  context<span class="token punctuation">.</span><span class="token function">lineTo</span><span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 描画路径</span>
  context<span class="token punctuation">.</span><span class="token function">stroke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子使用 arc()绘制了两个圆形，一个外圆和一个内圆，以构成表盘的边框。外圆半径 99 像素，原点为(100,100)，也就是画布的中心。要绘制完整的圆形，必须从 0 弧度绘制到 2π 弧度（使用数学常量 Math.PI）。而在绘制内圆之前，必须先把路径移动到内圆上的一点，以避免绘制出多余的线条。第二次调用 arc()时使用了稍小一些的半径，以呈现边框效果。然后，再组合运用 moveTo()和 lineTo()分别绘制分针和时针。最后一步是调用 stroke()，得到如图 18-4 所示的图像。</p><iframe src="/red-treasure-book/dist/html/18-4.html" frameborder="0" scrolling="no" height="220"></iframe><p>路径是 2D 上下文的主要绘制机制，为绘制结果提供了很多控制。因为路径经常被使用，所以也有一个 isPointInPath()方法，接收 x 轴和 y 轴坐标作为参数。这个方法用于确定指定的点是否在路径上，可以在关闭路径前随时调用，比如：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">isPointInPath</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;Point (100, 100) is in the path.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2D 上下文的路径 API 非常可靠，可用于创建涉及各种填充样式、描述样式等的复杂图像。</p><h3 id="_18-3-4-绘制文本" tabindex="-1"><a class="header-anchor" href="#_18-3-4-绘制文本" aria-hidden="true">#</a> 18.3.4 绘制文本</h3><p>文本和图像混合也是常见的绘制需求，因此 2D 绘图上下文还提供了绘制文本的方法，即 fillText()和 strokeText()。这两个方法都接收 4 个参数：要绘制的字符串、x 坐标、y 坐标和可选的最大像素宽度。而且，这两个方法最终绘制的结果都取决于以下 3 个属性。</p><ul><li>font：以 CSS 语法指定的字体样式、大小、字体族等，比如&quot;10px Arial&quot;。</li><li>textAlign：指定文本的对齐方式，可能的值包括&quot;start&quot;、&quot;end&quot;、&quot;left&quot;、&quot;right&quot;和&quot;center&quot;。推荐使用&quot;start&quot;和&quot;end&quot;，不使用&quot;left&quot;和&quot;right&quot;，因为前者无论在从左到右书写的语言还是从右到左书写的语言中含义都更明确。</li><li>textBaseLine ：指定文本的基线，可能的值包括 &quot;top&quot; 、 &quot;hanging&quot; 、 &quot;middle&quot; 、&quot;alphabetic&quot;、&quot;ideographic&quot;和&quot;bottom&quot;。</li></ul><p>这些属性都有相应的默认值，因此没必要每次绘制文本时都设置它们。fillText()方法使用 fillStyle 属性绘制文本，而 strokeText()方法使用 strokeStyle 属性。通常，fillText()方法是使用最多的，因为它模拟了在网页中渲染文本。例如，下面的例子会在前一节示例的表盘顶部绘制数字“12”：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>context<span class="token punctuation">.</span>font <span class="token operator">=</span> <span class="token string">&quot;bold 14px Arial&quot;</span><span class="token punctuation">;</span>
context<span class="token punctuation">.</span>textAlign <span class="token operator">=</span> <span class="token string">&quot;center&quot;</span><span class="token punctuation">;</span>
context<span class="token punctuation">.</span>textBaseline <span class="token operator">=</span> <span class="token string">&quot;middle&quot;</span><span class="token punctuation">;</span>
context<span class="token punctuation">.</span><span class="token function">fillText</span><span class="token punctuation">(</span><span class="token string">&quot;12&quot;</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果就得到了如图 18-5 所示的图像。</p><iframe src="/red-treasure-book/dist/html/18-5.html" frameborder="0" scrolling="no" height="220"></iframe><p>因为把 textAlign 设置为了&quot;center&quot;，把 textBaseline 设置为了&quot;middle&quot;，所以(100, 20)表示文本水平和垂直中心点的坐标。如果 textAlign 是&quot;start&quot;，那么 x 坐标在从左到右书写的语言中表示文本的左侧坐标，而&quot;end&quot;会让 x 坐标在从左到右书写的语言中表示文本的右侧坐标。例如：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 正常</span>
context<span class="token punctuation">.</span>font <span class="token operator">=</span> <span class="token string">&quot;bold 14px Arial&quot;</span><span class="token punctuation">;</span>
context<span class="token punctuation">.</span>textAlign <span class="token operator">=</span> <span class="token string">&quot;center&quot;</span><span class="token punctuation">;</span>
context<span class="token punctuation">.</span>textBaseline <span class="token operator">=</span> <span class="token string">&quot;middle&quot;</span><span class="token punctuation">;</span>
context<span class="token punctuation">.</span><span class="token function">fillText</span><span class="token punctuation">(</span><span class="token string">&quot;12&quot;</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 与开头对齐</span>
context<span class="token punctuation">.</span>textAlign <span class="token operator">=</span> <span class="token string">&quot;start&quot;</span><span class="token punctuation">;</span>
context<span class="token punctuation">.</span><span class="token function">fillText</span><span class="token punctuation">(</span><span class="token string">&quot;12&quot;</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 与末尾对齐</span>
context<span class="token punctuation">.</span>textAlign <span class="token operator">=</span> <span class="token string">&quot;end&quot;</span><span class="token punctuation">;</span>
context<span class="token punctuation">.</span><span class="token function">fillText</span><span class="token punctuation">(</span><span class="token string">&quot;12&quot;</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>字符串&quot;12&quot;被绘制了 3 次，每次使用的坐标都一样，但 textAlign 值不同。为了让每个字符串不至于重叠，每次绘制的 y 坐标都会设置得大一些。结果就是如图 18-6 所示的图像。</p><iframe src="/red-treasure-book/dist/html/18-6.html" frameborder="0" scrolling="no" height="220"></iframe><p>因为表盘中垂直的线条是居中的，所以文本的对齐方式就一目了然了。类似地，通过修改 textBaseline 属性，可以改变文本的垂直对齐方式。比如，设置为&quot;top&quot;意味着 y 坐标表示文本顶部，&quot;bottom&quot;表示文本底部，&quot;hanging&quot;、&quot;alphabetic&quot;和&quot;ideographic&quot;分别引用字体中特定的基准点。</p><p>由于绘制文本很复杂，特别是想把文本绘制到特定区域的时候，因此 2D 上下文提供了用于辅助确定文本大小的 measureText()方法。这个方法接收一个参数，即要绘制的文本，然后返回一个 TextMetrics 对象。这个返回的对象目前只有一个属性 width，不过将来应该会增加更多度量指标。</p><p>measureText()方法使用 font、textAlign 和 textBaseline 属性当前的值计算绘制指定文本后的大小。例如，假设要把文本&quot;Hello world!&quot;放到一个 140 像素宽的矩形中，可以使用以下代码，从 100 像素的字体大小开始计算，不断递减，直到文本大小合适：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> fontSize <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
context<span class="token punctuation">.</span>font <span class="token operator">=</span> fontSize <span class="token operator">+</span> <span class="token string">&quot;px Arial&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">measureText</span><span class="token punctuation">(</span><span class="token string">&quot;Hello world!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>width <span class="token operator">&gt;</span> <span class="token number">140</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  fontSize<span class="token operator">--</span><span class="token punctuation">;</span>
  context<span class="token punctuation">.</span>font <span class="token operator">=</span> fontSize <span class="token operator">+</span> <span class="token string">&quot;px Arial&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
context<span class="token punctuation">.</span><span class="token function">fillText</span><span class="token punctuation">(</span><span class="token string">&quot;Hello world!&quot;</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
context<span class="token punctuation">.</span><span class="token function">fillText</span><span class="token punctuation">(</span><span class="token string">&quot;Font size is &quot;</span> <span class="token operator">+</span> fontSize <span class="token operator">+</span> <span class="token string">&quot;px&quot;</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>fillText()和 strokeText()方法还有第四个参数，即文本的最大宽度。这个参数是可选的（Firefox 4 是第一个实现它的浏览器），如果调用 fillText()和 strokeText()时提供了此参数，但要绘制的字符串超出了最大宽度限制，则文本会以正确的字符高度绘制，这时字符会被水平压缩，以达到限定宽度。图 18-7 展示了这个参数的效果。</p><iframe src="/red-treasure-book/dist/html/18-7.html" frameborder="0" scrolling="no" height="200"></iframe><p>绘制文本是一项比较复杂的操作，因此支持<code>&lt;canvas&gt;</code>元素的浏览器不一定全部实现了相关的文本绘制 API。</p><h3 id="_18-3-5-变换" tabindex="-1"><a class="header-anchor" href="#_18-3-5-变换" aria-hidden="true">#</a> 18.3.5 变换</h3></div><!--[--><!--]--></div><footer class="page-meta"><!----><!----><!----></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/red-treasure-book/dist/%E7%AC%AC17%E7%AB%A0%20_%E4%BA%8B%E4%BB%B6.html" class="" aria-label="第17章 事件"><!--[--><!--]--> 第17章 事件 <!--[--><!--]--></a></span><!----></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/red-treasure-book/dist/assets/app.eb5b74ec.js" defer></script>
  </body>
</html>
